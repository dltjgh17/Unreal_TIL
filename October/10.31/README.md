아래는 요청하신 면접 질문 리스트에 대해 **정돈된 형태 + 기술 면접 수준의 깊이**로 답변한 예시입니다.
(답변 형식: **핵심 개념 → 상세 설명 → 예시 또는 꼬리 질문 대비 포인트**)

---

## ✅ **컴퓨터의 메모리 구조에 대해 설명해주세요.**

컴퓨터의 메모리는 **계층 구조(Hierarchy)**로 이루어져 있으며, 상위로 갈수록 **빠르고 용량이 작고 비싸며**, 하위로 갈수록 **느리고 용량이 크고 저렴**합니다.

| 계층 | 종류               | 특징              | 속도    | 크기    |
| -- | ---------------- | --------------- | ----- | ----- |
| 1  | 레지스터             | CPU 내부 저장소      | 가장 빠름 | 매우 작음 |
| 2  | L1/L2/L3 캐시      | 자주 쓰는 데이터 미리 저장 | 매우 빠름 | 작음    |
| 3  | 메인 메모리(RAM)      | 실행 중 프로그램 보관    | 보통    | 중간    |
| 4  | 보조 기억장치(SSD/HDD) | 파일, 프로그램 저장     | 느림    | 큼     |

### ❓ 어떤 메모리가 가장 빠르고 느린가요?

* **가장 빠름**: CPU 레지스터, L1 캐시
* **가장 느림**: HDD (또는 네트워크/원격 저장 장치)

---

## ✅ **캐시의 지역성(Locality)에 대해 설명해주세요.**

지역성은 CPU가 데이터를 접근할 때 특정 패턴이 있다는 원리입니다.

### ✔️ 시간 지역성 (Temporal Locality)

같은 데이터는 **시간적으로 가까운 시점에 다시 사용**될 가능성이 높음

> 예: 반복문에서 같은 변수 계속 사용

### ✔️ 공간 지역성 (Spatial Locality)

메모리에서 **가까운 주소의 데이터가 함께 사용**될 가능성이 높음

> 예: 배열 순차 접근

---

## ✅ **가상 메모리에 대해 설명해주세요.**

가상 메모리는 **물리 메모리보다 더 큰 메모리를 사용하는 것처럼 보이게 만드는 기술**입니다.

* 실제 RAM이 부족하면 **디스크 공간(Swap/Pagefile)**을 사용
* 프로세스마다 **독립된 주소 공간**을 제공 → 안정성 & 보안

### ✔️ 페이지(Page) 단위 관리

* 메모리를 일정한 크기(4KB 등)로 나누어 관리

### ❓ 페이지 폴트(Page Fault)란?

프로세스가 요청한 메모리가 **RAM에 없을 때 발생하는 예외**
→ OS가 디스크에서 해당 페이지를 가져옴 (매우 느림)

---

## ✅ **CPU와 GPU에 대해 설명해주세요.**

| 항목 | CPU               | GPU            |
| -- | ----------------- | -------------- |
| 구조 | 소수의 강력한 코어        | 수천 개의 경량 코어    |
| 목적 | 일반 연산, 분기, 복잡한 논리 | 대량 병렬 연산       |
| 장점 | 단일 스레드 성능 강함      | 병렬 처리에 최적      |
| 예시 | 게임 로직, OS 연산      | 그래픽 렌더링, AI 학습 |

---

## ✅ **C/C++ 빌드 프로세스**

1. **Preprocessing (전처리):** `#include`, `#define` 처리
2. **Compilation (컴파일):** C/C++ → Assembly
3. **Assembly (어셈블링):** Assembly → Object file (`.o`, `.obj`)
4. **Linking (링킹):** 여러 오브젝트 파일을 하나로 합쳐 실행 파일 생성

---

## ✅ **프로그램의 프로세스(Process)에 대해 설명해주세요.**

**프로세스는 실행 중인 프로그램의 인스턴스**입니다.

### ✔️ 프로세스 메모리 구조

| 영역         | 설명           |
| ---------- | ------------ |
| Code(text) | 프로그램 명령어     |
| Data       | 전역/정적 변수     |
| Heap       | 동적 할당 메모리    |
| Stack      | 함수 호출, 지역 변수 |

### ❓ 스택 오버플로우란?

스택 영역이 초과된 상태

> 무한 재귀 호출 = 대표적 예

---

### ❓ 프로세스와 스레드 차이

| 항목  | 프로세스       | 스레드          |
| --- | ---------- | ------------ |
| 정의  | 실행 단위      | 프로세스 내 실행 단위 |
| 메모리 | 독립된 메모리 공간 | 프로세스 메모리 공유  |
| 통신  | IPC 필요     | 공유 메모리로 빠름   |

---

## ✅ **컨텍스트 스위칭(Context Switching)이란?**

CPU가 다른 작업을 수행하기 위해 **현재 작업 상태 레지스터 저장 → 다음 작업 상태 로딩**하는 과정

### ❓ 비용 줄이는 방법?

* 스레드 사용 (프로세스보다 부담 적음)
* 적절한 스케줄링 정책
* Lock 최소화 → 병목 줄이기

---

## ✅ **메모리 단편화란?**

메모리가 작은 조각으로 나뉘어 **연속 공간이 부족해 할당 실패**하는 현상

### ✔️ 해결 방법

* **압축(Compaction)**: 메모리 재배치
* **페이징/세그멘테이션**: 논리적 분할
* **메모리 풀 사용**: 고정 크기 블록 미리 확보

---

## ✅ **데드락(Deadlock)이란?**

서로 자원을 기다리며 **무한 대기 상태**에 빠지는 문제

### 발생 조건(4가지 — Coffman 조건)

1. 상호 배제
2. 점유 & 대기
3. 비선점
4. 순환 대기

**하나라도 깨면 해결 가능**

---

## ✅ **임계 영역(Critical Section)**

공유 자원에 접근하는 코드 구역
→ 동시 접근 시 데이터 무결성 깨짐
→ Mutex, Semaphore 등으로 보호

---

## ✅ **Busy-waiting이란?**

CPU가 lock 해제될 때까지 **계속 루프 돌며 기다리는 것**
(= Spin lock 형태)
CPU 낭비 → 커널에서 sleep 방식 선호

---

## ✅ **리틀 엔디안 & 빅 엔디안**

| 방식            | 설명             | 예 (0x12345678) |
| ------------- | -------------- | -------------- |
| Little endian | **LSB가 먼저 저장** | 78 56 34 12    |
| Big endian    | **MSB가 먼저 저장** | 12 34 56 78    |

---

## ✅ **Mutex vs Semaphore**

| 항목  | Mutex             | Semaphore          |
| --- | ----------------- | ------------------ |
| 목적  | 상호 배제 (exclusive) | 허용 가능한 동시 접근 수     |
| 카운트 | 1                 | N                  |
| 소유권 | 있음 (owner unlock) | 없음                 |
| 예   | 파일 쓰기             | DB connection pool |

---

## ✅ **TCP vs UDP**

| 항목    | TCP   | UDP      |
| ----- | ----- | -------- |
| 연결 방식 | 연결 기반 | 비연결      |
| 신뢰성   | 보장    | 보장 X     |
| 속도    | 느림    | 빠름       |
| 사용 예  | 웹, 메일 | 게임, 스트리밍 |

---

## 📌 마무리 팁

면접에서는 아래처럼 추가 대응 멘트를 붙이면 좋습니다:

> “이외에도 상황에 따라 OS 스케줄링, 메모리 관리 정책, CPU 파이프라인 구조 등이 함께 고려됩니다.”

---

아래는 **C/C++ 면접 대비용 고퀄 답변 템플릿**입니다.
(핵심 → 상세 설명 → 꼬리질문 대비 포인트 형식)

---

## ✅ C 언어와 C++ 언어의 차이점은 무엇인가요?

| C          | C++                   |
| ---------- | --------------------- |
| 절차 지향 언어   | 객체 지향 + 절차 지향         |
| 함수 중심      | 객체 중심                 |
| 구조체에 함수 X  | 클래스(멤버 변수 + 함수)       |
| 메모리 수동 관리  | RAII / 스마트 포인터 제공     |
| 함수 오버로딩 불가 | 오버로딩 지원               |
| 예외 처리 미약   | `try-catch`, 예외 처리 지원 |

> 결론: C는 하드웨어 가까운 시스템 언어, C++은 확장된 시스템 + 객체지향 언어

---

## ✅ C++에서 클래스와 구조체의 차이점

(C++ 기준)

| struct                | class                  |
| --------------------- | ---------------------- |
| **기본 접근 지정자: public** | **기본 접근 지정자: private** |
| 주로 데이터 구조             | 추상화된 객체 설계             |
| 상속 시 기본 public        | 상속 시 기본 private        |

### 💡 C언어 struct vs C++ struct

| C struct  | C++ struct       |
| --------- | ---------------- |
| 데이터만      | 멤버 함수/상속/캡슐화 가능  |
| OOP 기능 없음 | 사실상 class와 거의 동일 |

---

## ✅ 포인터 vs 레퍼런스

| 포인터          | 레퍼런스       |
| ------------ | ---------- |
| 다른 변수 주소 저장  | 메모리 별칭(참조) |
| `nullptr` 가능 | 반드시 초기화 필요 |
| 재할당 가능       | 재할당 불가     |

### 💡 댕글링 포인터(Dangling Pointer)

이미 **삭제된 메모리를 가리키는 포인터**

```cpp
int* p = new int(10);
delete p;
*p = 20; // 위험
```

### 💡 void 포인터

**타입이 없는 포인터**, 어떤 포인터도 담을 수 있음
사용 시 캐스팅 필요

---

## ✅ 동적 할당이란?

프로그램 실행 중 메모리 할당
→ `new/delete`, `malloc/free`

### 💡 깊은 복사 vs 얕은 복사

| 얕은 복사          | 깊은 복사             |
| -------------- | ----------------- |
| 포인터 주소만 복사     | 포인터가 참조하는 데이터를 복사 |
| double free 위험 | 안전                |

---

## ✅ malloc/free vs new/delete

| malloc / free | new / delete   |
| ------------- | -------------- |
| C 방식 메모리 할당   | C++ 객체 생성 및 소멸 |
| 타입 정보 없음      | 생성자/소멸자 호출     |
| `void*` 반환    | 타입 맞춰 반환       |

---

## ✅ C++ 캐스트 연산자

| 캐스트                | 용도                 |
| ------------------ | ------------------ |
| `static_cast`      | 기본 타입 변환, 상속 안전 변환 |
| `dynamic_cast`     | 런타임 타입 체크, 다운캐스팅   |
| `const_cast`       | const 제거           |
| `reinterpret_cast` | 비트 단위 변환(위험)       |

### 💡 dynamic_cast 조건

* RTTI 필요 (`virtual` 함수가 있는 클래스)
* 다운캐스팅 실패 시 `nullptr`

### 💡 RTTI란?

**런타임 타입 정보**
`typeid`, `dynamic_cast` 지원

---

## ✅ static 키워드

| 의미         | 설명                |
| ---------- | ----------------- |
| 정적 저장      | 프로그램 종료까지 생존      |
| 클래스 static | 공유 멤버             |
| 파일 static  | 파일 내에서만 사용(내부 연결) |

---

## ✅ const 키워드

| 형태                         | 의미        |
| -------------------------- | --------- |
| `const int a`              | 읽기 전용 변수  |
| `int* const p`             | 포인터 자체 불변 |
| `const int* p`             | 데이터 불변    |
| `const class Func() const` | 멤버 수정 금지  |

---

## ✅ 가상 함수 (Virtual Function)

런타임 다형성 구현

### 💡 소멸자에 virtual 붙이는 이유

부모 포인터로 자식 삭제 시 **자식 소멸자 호출 보장**

```cpp
virtual ~Base(){}
```

### 💡 순수 가상 함수

```cpp
virtual void Func() = 0;
```

→ 인터페이스 역할

### 💡 가상 함수 테이블(VTable)

* virtual 함수 목록 저장 테이블
* 객체당 vptr이 테이블을 가리킴

---

## ✅ 바인딩 (Binding)

| 정적 바인딩 | 동적 바인딩 |
| ------ | ------ |
| 컴파일 타임 | 런타임    |
| 오버로딩   | 오버라이딩  |

---

## ✅ 오버로딩 vs 오버라이딩

| 오버로딩          | 오버라이딩     |
| ------------- | --------- |
| 같은 이름 다른 매개변수 | 부모 함수 재정의 |
| 컴파일 타임        | 런타임       |
| 한 클래스 내       | 상속 관계     |

---

## ✅ STL 설명

표준 템플릿 라이브러리
📦 **컨테이너 + 알고리즘 + 반복자**

### ✔️ 컨테이너 종류 요약

| 컨테이너          | 특징         |
| ------------- | ---------- |
| vector        | 동적 배열      |
| list          | 양방향 연결 리스트 |
| map           | 균형 트리      |
| unordered_map | 해시 기반      |

---

### Vector vs List

| vector     | list       |
| ---------- | ---------- |
| 연속 메모리     | 노드 연결      |
| 임의 접근 O(1) | 임의 접근 불가   |
| 중간 삽입 O(n) | 중간 삽입 O(1) |

### push_back vs emplace_back

| push_back  | emplace_back    |
| ---------- | --------------- |
| 객체 생성 후 삽입 | 객체 직접 생성(복사 없음) |

---

### Set vs Map

| Set  | Map       |
| ---- | --------- |
| 중복 X | key-value |
| 정렬됨  | 정렬됨       |

---

### unordered_map vs map

| map            | unordered_map |
| -------------- | ------------- |
| Red-Black Tree | Hash Table    |
| O(log n)       | O(1) 평균       |
| 정렬             | 비정렬           |

#### 해시 함수?

키 → 해시값 변환

#### 해시 충돌?

서로 다른 키가 같은 해시 값

#### 해결 방법

* 체이닝
* 오픈 어드레싱

---

### 시간 복잡도 정리

| 연산       | vector | list | map      |
| -------- | ------ | ---- | -------- |
| 임의 접근    | O(1)   | X    | O(log n) |
| 검색       | O(n)   | O(n) | O(log n) |
| 중간 삽입/삭제 | O(n)   | O(1) | O(log n) |

---

## ✅ RValue & LValue

| LValue | RValue     |
| ------ | ---------- |
| 주소 있음  | 일시적 값      |
| 변수     | 리턴값, 임시 객체 |

### 호출 시점

| 생성자   | 대입 연산자        |
| ----- | ------------- |
| 선언될 때 | 이미 생성된 객체에 대입 |

---

### ✅ Move semantics / `std::move`

리소스를 복사하지 않고 **소유권 이동**

```cpp
std::string a = "hi";
std::string b = std::move(a);
```

---

### ✅ RVO (Return Value Optimization)

리턴 값 복사를 컴파일러가 제거

---

## ✅ 매크로 vs inline

| 매크로     | inline    |
| ------- | --------- |
| 전처리 치환  | 함수 인라인 확장 |
| 타입 체크 X | 타입 체크 O   |
| 디버깅 어려움 | 컴파일 단계    |

---

## ✅ 스마트 포인터

| 종류           | 기능       |
| ------------ | -------- |
| `unique_ptr` | 단독 소유    |
| `shared_ptr` | 참조 카운트   |
| `weak_ptr`   | 순환 참조 방지 |

### RAII

리소스 획득 = 객체 생성
해제 = 소멸자

---

## ✅ 스마트 포인터 사용 경험 예시 (면접용)

> Unreal Engine 작업 시 `TSharedPtr`, `TWeakObjectPtr` 사용했습니다.
> 객체 생명 주기 관리, 순환 참조 방지 목적이며
> C++ 표준에서는 `unique_ptr`로 단독 소유,
> `shared_ptr`로 딱 필요한 상황에만 공유했습니다.

---

## 🎯 마무리

원하면 아래 포맷으로도 만들어드림:

* 📄 PDF 면접 요약자료
* 🎤 발표 스크립트 버전
* ✍️ 주석 포함 코드 예제 버전
* 🎮 게임 개발/Unreal Engine 관점 응답 버전

필요하시면 **"이 질문 리스트 꼬리질문도 만들어줘"** 해주시면 됩니다!
